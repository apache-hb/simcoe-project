#include "stdafx.hpp"

#include "writer.hpp"

using namespace llvm;
using namespace clang;

namespace fs = std::filesystem;

static constexpr std::string_view kMetaHeaderContent = R"(
#pragma once
#include "meta/meta.hpp"
using namespace sm::reflect::detail;
)";

static constexpr std::string_view kWarningComment = R"(
/* This file is generated by the meta reflection tool. */
/* Changes to this file will be lost. */
)";

static void replaceAll(std::string &str, std::string_view search, std::string_view replace) {
    size_t pos = 0;
    while ((pos = str.find(search, pos)) != std::string::npos) {
        str.replace(pos, search.length(), replace);
        pos += replace.length();
    }
}

static std::string getNamespaceAsString(const NamedDecl& decl) {
    std::string name;
    llvm::raw_string_ostream OS(name);
    decl.printNestedNameSpecifier(OS);

    // trim trailing ::
    return OS.str().substr(0, name.size() - 2);
}

static std::string makePackageName(std::string_view name) {
    std::string result{name};
    replaceAll(result, "::", ".");
    return result;
}

class StubFile final : public vfs::File {
    vfs::Status mStatus;

public:
    StubFile(vfs::Status status)
        : mStatus(std::move(status))
    { }

    ErrorOr<vfs::Status> status() override {
        return mStatus;
    }

    ErrorOr<std::unique_ptr<MemoryBuffer>>
    getBuffer(const Twine &name, int64_t size, bool RequiresNullTerminator, bool IsVolatile) override {
        return MemoryBuffer::getMemBuffer(kMetaHeaderContent, name.getSingleStringRef(), RequiresNullTerminator);
    }

    std::error_code close() override {
        return std::error_code();
    }
};

class ReflectFileSystem final : public vfs::ProxyFileSystem {
    static constexpr uint64_t kUniqueID = 0x12345678;

    vfs::Status mStatus = vfs::Status(
        "stub.meta.hpp",
        sys::fs::UniqueID(0, kUniqueID),
        std::chrono::system_clock::now(),
        0, 0,
        kMetaHeaderContent.size(),
        sys::fs::file_type::regular_file,
        sys::fs::all_all
    );

    static bool isReflectHeader(llvm::StringRef path) {
        return path.ends_with(".meta.hpp");
    }
public:
    ReflectFileSystem()
        : ProxyFileSystem(vfs::getRealFileSystem())
    { }

    ErrorOr<vfs::Status> status(const Twine &path) override {
        if (isReflectHeader(path.str())) {
            return mStatus;
        }

        return ProxyFileSystem::status(path);
    }

    ErrorOr<std::unique_ptr<vfs::File>>
    openFileForRead(const Twine &path) override {
        if (!isReflectHeader(path.str()))
            return ProxyFileSystem::openFileForRead(path);

        return std::make_unique<StubFile>(mStatus);
    }
};

std::unique_ptr<vfs::FileSystem> createOverlayFileSystem() {
    return std::make_unique<ReflectFileSystem>();
}

static fs::path gInputPath;
static fs::path gSourcePath;
static fs::path gHeaderPath;

static constexpr const char *kReflectTag = "meta";

class MetaAttrInfo final : public ParsedAttrInfo {
    static constexpr Spelling kSpellings[] = {
        {ParsedAttr::AS_GNU, "simcoe_meta"},
        {ParsedAttr::AS_Microsoft, "simcoe_meta"},
        {ParsedAttr::AS_CXX11, "simcoe_meta"}
    };

    static void addAnnotation(Sema &sema, Decl &decl, const ParsedAttr &attr) {
        SmallVector<Expr*, 16> exprs;
        for (unsigned i = 0; i < attr.getNumArgs(); i++) {
            exprs.push_back(attr.getArgAsExpr(i));
        }

        decl.addAttr(AnnotateAttr::Create(decl.getASTContext(), kReflectTag, exprs.data(), exprs.size(), attr.getRange()));

        const AttributeCommonInfo attrInfo{attr.getLoc(), attr.getKind(), attr.getForm()};
        sema.ConstantFoldAttrArgs(attrInfo, exprs);
    }

    AttrHandling handleDeclAttribute(Sema &sema, Decl *decl, const ParsedAttr &attr) const override {
        CTASSERT(decl != nullptr);

        addAnnotation(sema, *decl, attr);
        return AttributeApplied;
    }

public:
    MetaAttrInfo() {
        OptArgs = 15;
        Spellings = kSpellings;
    }
};

class CmdAfterConsumer final : public ASTConsumer {
    static bool isMetaTarget(const Decl& decl) {
        if (!decl.getLocation().isFileID())
            return false;

        const SourceManager &sm = decl.getASTContext().getSourceManager();
        if (const FileEntry *entry = sm.getFileEntryForID(sm.getFileID(decl.getLocation()))) {
            fs::path realpath{entry->tryGetRealPathName().str()};
            if (!fs::equivalent(realpath, gInputPath))
                return false;
        }

        if (const AnnotateAttr *attr = decl.getAttr<AnnotateAttr>()) {
            return attr->getAnnotation() == kReflectTag;
        }

        return false;
    }

    DiagnosticsEngine &mDiag;

    std::ostringstream mSourceBody;
    std::ostringstream mHeaderBody;

    Writer mSource{mSourceBody};
    Writer mHeader{mHeaderBody};

    void Initialize(ASTContext&) override {
        mSource.writeln(kWarningComment);

        auto parent = gInputPath.parent_path().filename().string();
        auto filename = gInputPath.filename().string();

        mSource.writeln("#include \"{}/{}\"", parent, filename);

        mHeader.writeln(kWarningComment);

        mHeader.writeln("#pragma once");
        mHeader.writeln("#include \"meta/meta.hpp\"");
    }

    void reflectEnum(const EnumDecl& decl, std::string_view id) {
        auto name = decl.getNameAsString();
        auto ns = getNamespaceAsString(decl);
        mHeader.writeln("namespace {} {{", ns);
        mHeader.indent();

        if (auto underlying = decl.getIntegerType(); underlying->isBuiltinType()) {
            mHeader.writeln("enum class {};", name);
        } else {
            mHeader.writeln("enum class {} : {};", name, underlying->getTypeClassName());
        }
        mHeader.writeln("std::string_view toString({} it) noexcept;", name);

        mSource.writeln("std::string_view {}::toString({} it) noexcept {{", ns, name);
        mSource.indent();

        mSource.writeln("switch (it) {{");
        mSource.writeln("using enum {};", name);
        for (auto *enumerator : decl.enumerators()) {
            mSource.writeln("case {0}: return \"{0}\";", enumerator->getNameAsString());
        }
        mSource.writeln("default: return \"unknown\";");
        mSource.writeln("}}");

        mSource.dedent();
        mSource.writeln("}}");

        mHeader.dedent();
        mHeader.writeln("}} // namespace {}", ns);

        mHeader.writeln("#define {}", id);
    }

    void reflectRecord(const CXXRecordDecl& decl, std::string_view id) {
        auto name = decl.getNameAsString();
        auto ns = getNamespaceAsString(decl);
        auto package = makePackageName(ns);

        mHeader.writeln("namespace {} {{", ns);
        mHeader.indent();

        mHeader.dedent();
        mHeader.writeln("}} // namespace {}", ns);

        mHeader.writeln("#define {} \\", id);
        mHeader.indent();
        mHeader.writeln("public: \\");
        mHeader.indent();
        mHeader.writeln("static const sm::reflect::Class& getClass() noexcept; \\");
        mHeader.dedent();
        mHeader.writeln("{}", decl.isClass() ? "private:" : "public:");
        mHeader.dedent();

        mSource.writeln("template<> struct sm::reflect::detail::ClassImpl<{}::{}> {{", ns, name);
        mSource.indent();
        mSource.writeln("static constexpr std::string_view kName = \"{}\";", name);
        mSource.writeln("static constexpr std::string_view kPackage = \"{}\";", package);
        mSource.dedent();
        mSource.writeln("}};");
    }

public:
    CmdAfterConsumer(DiagnosticsEngine &diag)
        : mDiag(diag)
    { }

    ~CmdAfterConsumer() {
        std::ofstream source;
        std::ofstream header;

        source.open(gSourcePath);
        header.open(gHeaderPath);

        if (!source.is_open()) {
            mDiag.Report(diag::err_cannot_open_file) << gSourcePath.string();
            return;
        }

        if (!header.is_open()) {
            mDiag.Report(diag::err_cannot_open_file) << gHeaderPath.string();
            return;
        }

        source << mSourceBody.str();
        header << mHeaderBody.str();
    }

    void HandleTagDeclDefinition(TagDecl *decl) override {
        if (!isMetaTarget(*decl))
            return;

        auto id = fmt::format("REFLECT_IMPL_{}", decl->getNameAsString());

        mHeader.writeln("#if defined({})", id);
        mHeader.writeln("#   undef {}", id);
        mHeader.writeln("#endif");

        if (decl->isEnum()) {
            reflectEnum(*cast<EnumDecl>(decl), id);
        } else if (decl->isRecord()) {
            reflectRecord(*cast<CXXRecordDecl>(decl), id);
        } else {
            decl->dump(llvm::outs());
        }
    }
};

class CmdAfterAction final : public PluginASTAction {
    std::unique_ptr<ASTConsumer>
    CreateASTConsumer(CompilerInstance &CI, StringRef InFile) override {
        return std::make_unique<CmdAfterConsumer>(CI.getDiagnostics());
    }

    bool ParseArgs(const CompilerInstance &CI, const std::vector<std::string> &args) override {
        return true;
    }

    PluginASTAction::ActionType getActionType() override {
        return AddAfterMainAction;
    }
};

static ParsedAttrInfoRegistry::Add<MetaAttrInfo> gMetaAction("simcoe-meta-attr", "Reflects a class");
static FrontendPluginRegistry::Add<CmdAfterAction> gAfterAction("cmd-after-action", "Run after action");

int main(int argc, const char **argv) {
    if (argc < 5) {
        llvm::errs() << "Usage: " << argv[0] << " <input> <header output> <source output> -- [options...]\n";
        return 1;
    }

    std::vector<const char*> args(argv, argv + argc);
    args.push_back("-Xclang");
    args.push_back("-D__REFLECT__");
    args.push_back("-std=c++latest");
    args.push_back(nullptr);
    argc = args.size() - 1;

    std::string error;
    std::unique_ptr options = tooling::FixedCompilationDatabase::loadFromCommandLine(argc, args.data(), error);
    if (!options) {
        llvm::errs() << "Failed to load compilation database: " << error << "\n";
        return 1;
    }

    std::unique_ptr fs = createOverlayFileSystem();

    const char *input = argv[1];

    gInputPath = input;
    gHeaderPath = argv[2];
    gSourcePath = argv[3];

    tooling::ClangTool tool(*options, {input}, std::make_shared<PCHContainerOperations>(), std::move(fs));

    return tool.run(tooling::newFrontendActionFactory<SyntaxOnlyAction>().get());
}
