/** This file is generated by the meta reflection tool. */
/** Changes to this file will be lost. */

#pragma once

#include "meta/meta.hpp"

#include <fmtlib/format.h>
{% for enum in enums %}
#if defined(REFLECT_IMPL_{{ enum.name }})
#   undef REFLECT_IMPL_{{ enum.name }}
#endif
{% endfor %}
{% for cls in classes %}
#if defined(REFLECT_IMPL_{{ cls.name }})
#   undef REFLECT_IMPL_{{ cls.name }}
#endif
{% endfor %}

{% for enum in enums %}
#define REFLECT_IMPL_{{ enum.name }}
namespace {{ enum.namespace }} {
    enum class {{ enum.name }}{% if enum.underlying_type is defined %} : {{ enum.underlying_type }}{% endif %};
    std::string_view toString({{ enum.name }} it) noexcept;
} // namespace {{enum.namespace}}
template<> struct fmt::formatter<{{ enum.namespace }}::{{ enum.name }}> : fmt::formatter<std::string_view> {
    constexpr fmt::format_context::iterator format({{ enum.namespace }}::{{ enum.name }} it, fmt::format_context& ctx) const {
        return fmt::formatter<std::string_view>::format({{ enum.namespace }}::toString(it), ctx);
    }
};
{% endfor %}


{% for cls in classes %}
namespace {{ cls.namespace }} {

} // namespace {{cls.namespace}}
#define REFLECT_IMPL_{{ cls.name }} \
    public: \
        static const sm::reflect::Class& getClass() noexcept; \
    {% if cls.is_class %}private:{% else %}public:{% endif %}
{% endfor %}
